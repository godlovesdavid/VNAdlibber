// Cloudflare Pages Function - Complete migration from routes.ts
import { JSON_FORMAT_INSTRUCTIONS, GEMINI_CONFIG, PROMPTS } from '../../shared/prompts';

// Helper function for Gemini API calls (using shared config)
async function generateWithGemini(
  prompt: string,
  systemPrompt: string | null = null,
  responseFormat = "JSON",
  maxOutputTokens = 4096, 
  isPro = false,
  apiKey: string
) {
  try {
    const headers = {
      "Content-Type": "application/json",
      "x-goog-api-key": apiKey,
    };

    // Add the JSON formatting instructions to the prompt
    const enhancedPrompt = prompt + "\n\n" + JSON_FORMAT_INSTRUCTIONS;
    console.log(enhancedPrompt);

    // Construct the request body
    const requestBody = {
      contents: [
        ...(systemPrompt
          ? [{ role: "model", parts: [{ text: systemPrompt }] }]
          : []),
        { role: "user", parts: [{ text: enhancedPrompt }] },
      ],
      generationConfig: {
        maxOutputTokens,
        temperature: 0.7,
      },
    };

    const apiUrl = isPro ? GEMINI_CONFIG.PRO_MODEL : GEMINI_CONFIG.LITE_MODEL;

    const response = await fetch(apiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Gemini API Error:", errorData);
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!content) {
      console.error("No content in Gemini response:", data);
      throw new Error("No content generated by Gemini");
    }

    return content;
  } catch (error) {
    console.error("Error in generateWithGemini:", error);
    throw error;
  }
}

// Content moderation function (exact copy from routes.ts)
async function moderateContent(
  input: string,
  apiKey?: string
): Promise<{ flagged: boolean; message: string; categories: any }> {
  try {
    if (!apiKey) {
      console.warn("OPENAI_API_KEY is not set. Skipping content moderation.");
      return {
        flagged: false,
        message: "OPENAI_API_KEY not set, content moderation skipped.",
        categories: {},
      };
    }

    const moderationResponse = await fetch(
      "https://api.openai.com/v1/moderations",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ input }),
      },
    );

    if (!moderationResponse.ok) {
      console.error(
        "OpenAI Moderation API error:",
        moderationResponse.status,
        moderationResponse.statusText,
      );
      return {
        flagged: false,
        message: "Content moderation service unavailable.",
        categories: {},
      };
    }

    const moderationData = await moderationResponse.json();
    const result = moderationData.results[0];

    if (result.flagged) {
      return {
        flagged: true,
        message: "Content violates community guidelines.",
        categories: result.categories,
      };
    }

    return {
      flagged: false,
      message: "Content is appropriate.",
      categories: result.categories,
    };
  } catch (error) {
    console.error("Error in content moderation:", error);
    return {
      flagged: false,
      message: "Content moderation service error.",
      categories: {},
    };
  }
}

export const onRequest = async (context: any) => {
  const { request, env } = context;
  const url = new URL(request.url);
  
  // Set CORS headers
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };

  // Handle OPTIONS requests
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  // Health check
  if (url.pathname === '/api/health') {
    return new Response(
      JSON.stringify({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        environment: 'cloudflare-pages'
      }),
      { 
        headers: { 
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      }
    );
  }

  // POST /api/generate/concept - Generate story concept (exact copy from routes.ts)
  if (url.pathname === '/api/generate/concept' && request.method === 'POST') {
    try {
      if (!env.GEMINI_API_KEY) {
        return new Response(
          JSON.stringify({ error: 'GEMINI_API_KEY not configured' }),
          { 
            status: 500,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          }
        );
      }

      const body = await request.json();
      const { basicData } = body;
      const { theme, tone, genre, setting } = basicData;

      const prompt = PROMPTS.CONCEPT(theme, tone, genre, setting);

      const result = await generateWithGemini(prompt, null, "JSON", 4096, false, env.GEMINI_API_KEY);
      const parsedResult = JSON.parse(result);

      return new Response(
        JSON.stringify(parsedResult),
        { 
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    } catch (error) {
      console.error("Error generating concept:", error);
      return new Response(
        JSON.stringify({ error: 'Failed to generate concept' }),
        { 
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    }
  }

  // POST /api/generate/plot - Generate story plot (exact copy from routes.ts)
  if (url.pathname === '/api/generate/plot' && request.method === 'POST') {
    try {
      if (!env.GEMINI_API_KEY) {
        return new Response(
          JSON.stringify({ error: 'GEMINI_API_KEY not configured' }),
          { 
            status: 500,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          }
        );
      }

      const body = await request.json();
      const { projectContext } = body;

      const prompt = PROMPTS.PLOT(projectContext);

      const result = await generateWithGemini(prompt, null, "JSON", 8192, true, env.GEMINI_API_KEY);
      const parsedResult = JSON.parse(result);

      return new Response(
        JSON.stringify(parsedResult),
        { 
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    } catch (error) {
      console.error("Error generating plot:", error);
      return new Response(
        JSON.stringify({ error: 'Failed to generate plot' }),
        { 
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    }
  }

  // Default response for unhandled routes
  return new Response(
    JSON.stringify({ 
      error: 'Route not implemented yet',
      path: url.pathname,
      method: request.method
    }),
    { 
      status: 404,
      headers: { 
        'Content-Type': 'application/json',
        ...corsHeaders
      }
    }
  );
};

// Helper function for Gemini API calls
async function generateWithGemini(prompt: string, apiKey: string) {
  const headers = {
    "Content-Type": "application/json",
    "x-goog-api-key": apiKey,
  };

  const jsonFormatInstructions = `
STRICT JSON FORMATTING RULES:
1. Return ONLY valid JSON without any explanatory text or markdown.
2. All property names must be in double quotes.
3. String values must use double quotes, not single quotes.
4. No trailing commas in arrays or objects.
5. No JavaScript-style comments in JSON.
6. Escape all quotes within strings.
7. Validate your JSON structure before returning it.
8. Do not include markdown code blocks in your response.
9. Every object property name must be quoted.
10. Use value null instead of string "null"

Example of CORRECT JSON format:
{
  "property": "value",
  "array": [1, 2, 3],
  "object": {
    "nested": true
  }
}`;

  const enhancedPrompt = prompt + "\n\n" + jsonFormatInstructions;

  const requestBody = {
    contents: [
      { role: "user", parts: [{ text: enhancedPrompt }] },
    ],
    generationConfig: {
      maxOutputTokens: 4096,
      temperature: 0.7,
    },
  };

  const response = await fetch(
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent",
    {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody),
    }
  );

  if (!response.ok) {
    throw new Error(`Gemini API error: ${response.status}`);
  }

  const data = await response.json();
  const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
  
  if (!text) {
    throw new Error("No response from Gemini API");
  }

  return JSON.parse(text);
}