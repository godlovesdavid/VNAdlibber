// Cloudflare Pages Function - Complete migration from routes.ts

// Helper function for Gemini API calls (exact copy from routes.ts)
async function generateWithGemini(
  prompt: string,
  systemPrompt: string | null = null,
  responseFormat = "JSON",
  maxOutputTokens = 4096, 
  isPro = false,
  apiKey: string
) {
  try {
    const headers = {
      "Content-Type": "application/json",
      "x-goog-api-key": apiKey,
    };

    // Add strict JSON formatting instructions
    const jsonFormatInstructions = `
STRICT JSON FORMATTING RULES:
1. Return ONLY valid JSON without any explanatory text or markdown.
2. All property names must be in double quotes.
3. String values must use double quotes, not single quotes.
4. No trailing commas in arrays or objects.
5. No JavaScript-style comments in JSON.
6. Escape all quotes within strings.
7. Validate your JSON structure before returning it.
8. Do not include markdown code blocks in your response.
9. Every object property name must be quoted.
10. Use value null instead of string "null"

Example of CORRECT JSON format:
{
  "property": "value",
  "array": [1, 2, 3],
  "object": {
    "nested": true
  }
}
`;
    // Add the JSON formatting instructions to the prompt
    const enhancedPrompt = prompt + "\n\n" + jsonFormatInstructions;
    console.log(enhancedPrompt);

    // Construct the request body
    const requestBody = {
      contents: [
        ...(systemPrompt
          ? [{ role: "model", parts: [{ text: systemPrompt }] }]
          : []),
        { role: "user", parts: [{ text: enhancedPrompt }] },
      ],
      generationConfig: {
        maxOutputTokens,
        temperature: 0.7,
      },
    };

    const apiUrl = isPro 
      ? "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent"
      : "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent";

    const response = await fetch(apiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Gemini API Error:", errorData);
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!content) {
      console.error("No content in Gemini response:", data);
      throw new Error("No content generated by Gemini");
    }

    return content;
  } catch (error) {
    console.error("Error in generateWithGemini:", error);
    throw error;
  }
}

// Content moderation function (exact copy from routes.ts)
async function moderateContent(
  input: string,
  apiKey?: string
): Promise<{ flagged: boolean; message: string; categories: any }> {
  try {
    if (!apiKey) {
      console.warn("OPENAI_API_KEY is not set. Skipping content moderation.");
      return {
        flagged: false,
        message: "OPENAI_API_KEY not set, content moderation skipped.",
        categories: {},
      };
    }

    const moderationResponse = await fetch(
      "https://api.openai.com/v1/moderations",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ input }),
      },
    );

    if (!moderationResponse.ok) {
      console.error(
        "OpenAI Moderation API error:",
        moderationResponse.status,
        moderationResponse.statusText,
      );
      return {
        flagged: false,
        message: "Content moderation service unavailable.",
        categories: {},
      };
    }

    const moderationData = await moderationResponse.json();
    const result = moderationData.results[0];

    if (result.flagged) {
      return {
        flagged: true,
        message: "Content violates community guidelines.",
        categories: result.categories,
      };
    }

    return {
      flagged: false,
      message: "Content is appropriate.",
      categories: result.categories,
    };
  } catch (error) {
    console.error("Error in content moderation:", error);
    return {
      flagged: false,
      message: "Content moderation service error.",
      categories: {},
    };
  }
}

export const onRequest = async (context: any) => {
  const { request, env } = context;
  const url = new URL(request.url);
  
  // Set CORS headers
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };

  // Handle OPTIONS requests
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  // Health check
  if (url.pathname === '/api/health') {
    return new Response(
      JSON.stringify({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        environment: 'cloudflare-pages'
      }),
      { 
        headers: { 
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      }
    );
  }

  // POST /api/generate/concept - Generate story concept (exact copy from routes.ts)
  if (url.pathname === '/api/generate/concept' && request.method === 'POST') {
    try {
      if (!env.GEMINI_API_KEY) {
        return new Response(
          JSON.stringify({ error: 'GEMINI_API_KEY not configured' }),
          { 
            status: 500,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          }
        );
      }

      const body = await request.json();
      const { basicData } = body;
      const { theme, tone, genre, setting } = basicData;

      const prompt = `Write a visual novel concept of a ${tone} ${genre} about ${theme} set in ${setting}.
        Return in this JSON format:
        {
          "title": "Captivating and unique title",
          "tagline": "Brief, memorable catchphrase",
          "premise": "Detailed premise describing the world, main conflict, and core story without specific character names"
        }`;

      const result = await generateWithGemini(prompt, null, "JSON", 4096, false, env.GEMINI_API_KEY);
      const parsedResult = JSON.parse(result);

      return new Response(
        JSON.stringify(parsedResult),
        { 
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    } catch (error) {
      console.error("Error generating concept:", error);
      return new Response(
        JSON.stringify({ error: 'Failed to generate concept' }),
        { 
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    }
  }

  // POST /api/generate/plot - Generate story plot (exact copy from routes.ts)
  if (url.pathname === '/api/generate/plot' && request.method === 'POST') {
    try {
      if (!env.GEMINI_API_KEY) {
        return new Response(
          JSON.stringify({ error: 'GEMINI_API_KEY not configured' }),
          { 
            status: 500,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          }
        );
      }

      const body = await request.json();
      const { projectContext } = body;

      const prompt = `Based on this visual novel concept, create a detailed plot outline. Focus on the overarching narrative structure, major story beats, and character development arcs.

Title: ${projectContext.title}
Premise: ${projectContext.premise}
Genre: ${projectContext.genre}
Tone: ${projectContext.tone}
Theme: ${projectContext.theme}
Setting: ${projectContext.setting}

Create a comprehensive plot that explores the theme through compelling conflicts and character growth. Return in this JSON format:
{
  "plotSummary": "A detailed overview of the complete story from beginning to end",
  "acts": [
    {
      "title": "Act title that reflects the dramatic progression",
      "description": "What happens in this act and its significance to the overall story",
      "themes": ["key themes explored in this act"]
    }
  ],
  "climax": "Description of the story's climactic moment",
  "resolution": "How the story concludes and themes are resolved"
}`;

      const result = await generateWithGemini(prompt, null, "JSON", 8192, true, env.GEMINI_API_KEY);
      const parsedResult = JSON.parse(result);

      return new Response(
        JSON.stringify(parsedResult),
        { 
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    } catch (error) {
      console.error("Error generating plot:", error);
      return new Response(
        JSON.stringify({ error: 'Failed to generate plot' }),
        { 
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        }
      );
    }
  }

  // Default response for unhandled routes
  return new Response(
    JSON.stringify({ 
      error: 'Route not implemented yet',
      path: url.pathname,
      method: request.method
    }),
    { 
      status: 404,
      headers: { 
        'Content-Type': 'application/json',
        ...corsHeaders
      }
    }
  );
};

// Helper function for Gemini API calls
async function generateWithGemini(prompt: string, apiKey: string) {
  const headers = {
    "Content-Type": "application/json",
    "x-goog-api-key": apiKey,
  };

  const jsonFormatInstructions = `
STRICT JSON FORMATTING RULES:
1. Return ONLY valid JSON without any explanatory text or markdown.
2. All property names must be in double quotes.
3. String values must use double quotes, not single quotes.
4. No trailing commas in arrays or objects.
5. No JavaScript-style comments in JSON.
6. Escape all quotes within strings.
7. Validate your JSON structure before returning it.
8. Do not include markdown code blocks in your response.
9. Every object property name must be quoted.
10. Use value null instead of string "null"

Example of CORRECT JSON format:
{
  "property": "value",
  "array": [1, 2, 3],
  "object": {
    "nested": true
  }
}`;

  const enhancedPrompt = prompt + "\n\n" + jsonFormatInstructions;

  const requestBody = {
    contents: [
      { role: "user", parts: [{ text: enhancedPrompt }] },
    ],
    generationConfig: {
      maxOutputTokens: 4096,
      temperature: 0.7,
    },
  };

  const response = await fetch(
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent",
    {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody),
    }
  );

  if (!response.ok) {
    throw new Error(`Gemini API error: ${response.status}`);
  }

  const data = await response.json();
  const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
  
  if (!text) {
    throw new Error("No response from Gemini API");
  }

  return JSON.parse(text);
}